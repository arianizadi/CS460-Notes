\documentclass[twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage[skip=6pt, indent=0pt]{parskip}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}

\title{CS 460 {-} Compilers}
\author{Arian Izadi}
\date{Spring 2024}

\begin{document}

\maketitle

\section{Languages}

Syntax is the rules for what a syntactically correct program looks like.
Semantics is the meaning of a program.

When does it matter the order of evaluation (right to left vs left to right)?
When the code has side effects, an example of this is postfix vs prefix increment (a++ vs ++a).

Compilers for a language L, move from front end $\to$ intermediate representation $\to$ back end.

\begin{itemize}
  \item Front end: Lexical Analysis, Syntax Analysis, and Semantic Analysis
  \item Intermediate: Intermediate Code
  \item Back end: Optimizer and Code Generation
\end{itemize}

\subsection{Lexical Analysis \& Scanning}

Lexical analysis, a scanner, is the process of converting a stream of characters into a stream of tokens.

\begin{enumerate}
  \item Find all terminals in the grammar.
  \item Write the Scanner.
        \begin{enumerate}
          \item Do we use a DFA, NFA, or PDA{?}
          \item Look at token types. All tokens can be expressed by a regular expression.
                \begin{enumerate}
                  \item Symbols: Semicolon, commas, etc.
                  \item Keywords: for, while, etc.
                  \item Variables: x, y, etc.
                  \item Numbers: 1, 3.14, 0{x}64, etc.
                \end{enumerate}
        \end{enumerate}
\end{enumerate}

\pagebreak

\paragraph*{Chomsky Language Hierarchy}

\begin{itemize}
  \item Type 0: Unrestricted (Turing Machines)
  \item Type 1: Context Sensitive
  \item Type 2: Context Free (PDA)
  \item Type 3: Regular Expressions (NFA, DFA)
\end{itemize}

Both RE and CFG have 1 non-terminal on the left of any combination of terminals and non-terminals on the right.

\textbf{Example 1:}

$S \to X$
\hfill
$X \to aXb | d$
\hfill
not regular: $a^n d b^n$

\textbf{Example 2:}

$S \to X$
\hfill
$X \to aX | b$
\hfill
regular: $a^* b$

\textbf{Example 3:}

$S \to X$
\hfill
$X \to aY | \epsilon$
\hfill
$Y \to bX$
\hfill
regular: $(ab){^*}$

An NFA for recognizing tokens, construct NFA for each construct of RE\@.

$\mathcal{E}$:

\begin{tikzpicture}[>=stealth, node distance=3cm, on grid, auto]
  \node[state, initial] (q1) {$q_1$};
  \node[state, accepting, right=of q1] (q2) {$q_2$};
  \path[->] (q1) edge node {$\epsilon$} (q2);
\end{tikzpicture}

$a \epsilon \Sigma$:

\begin{tikzpicture}[>=stealth, node distance=3cm, on grid, auto]
  \node[state, initial] (q1) {$q_1$};
  \node[state, accepting, right=of q1] (q2) {$q_2$};
  \path[->] (q1) edge node {$a$} (q2);
\end{tikzpicture}

\pagebreak

% $s | t$:

% \begin{tikzpicture}[>=stealth, node distance=2cm, on grid, auto]
%   \node[state, initial] (q1) {$q_1$};
%   \node[state, right=of q1] (q2) {$q_2$};
%   \node[state, accepting, right=of q2] (q3) {$q_3$};
%   \node[state, below=of q2] (q4) {$q_4$};

%   \path[->] (q1) edge node[above] {$\epsilon$} (q2);
%   \path[->] (q2) edge node[above] {$\epsilon$} (q3);
%   \path[->] (q1) edge node[left] {$\epsilon$} (q4);
%   \path[->] (q4) edge node[right] {$\epsilon$} (q3);
% \end{tikzpicture}


Any RE can be turned into an NFA using these rules.
If all the tokens of a language are represented by RE's, $r_1, \dots, r_n$.
Create an NFA for each RE\@.


\section{Parsing}

\subsection{Types of Parsers}

\begin{itemize}
  \item $LL(k)$ $-$ leftmost derivation
        \begin{itemize}
          \item (Hard Explain) Always develop the leftmost non terminal in a sentential form.
          \item Above means: Start at the start symbol and work towards the input.
        \end{itemize}
  \item $LR(k)$ $-$ rightmost derivation
        \begin{itemize}
          \item Reverse rightmost derivation.
          \item Above means: Start at input and work backwards to the start symbol.
        \end{itemize}
\end{itemize}

\paragraph*{Types of $LL(k)$ parsers:}

\begin{itemize}
  \item $LL(0)$ $-$ No look ahead and no left recursion.
  \item $LL(1)$ $-$ One look ahead and no left recursion.
  \item $LL(k)$ $-$ $k$ look ahead and no left recursion.
\end{itemize}

% example
\paragraph*{Example 1: $a^* b^*$}

% capital epsilon

$\lambda(a^* b^*) = {\mathcal{\epsilon}, a, b, aa, ab, bb, \dots}$

$S \to A$
\hfill
$A \to aA | B$
\hfill
$B \to bB | \mathcal{\epsilon}$

Try $w = aabb$:

$S \to_{LM} A \to_{LM} aA \to_{LM} aaA \to_{LM} aaB \to_{LM} aabB \to_{LM} aabbB \to_{LM} aabb$

What if B could generate strings starting with an $a$?

$S \to A$
\hfill
$A \to aA | B$
\hfill
$B \to bB | a | \mathcal{\epsilon}$

Try $w = aabb$:

It cannot be parsed by an $LL(1)$ parser.

\pagebreak

\paragraph*{A is not $LL(1)$ when}
\begin{itemize}
  \item $\exists w_1 \in \lambda (\alpha _1) \hat{}$
  \item $\exists w_2 \in \lambda (\alpha _2)$
  \item $w_1 = aw_1 \hat{}$
  \item $w_2 = aw_2$
\end{itemize}

\paragraph*{Example 2:}
A set representing tokens that a sentential form can start with: Call it $FIRST(\alpha)$

\begin{enumerate}
  \item $\mathcal{\epsilon}: $ FIRST ($\mathcal{\epsilon}$) = $\{\mathcal{\epsilon}\}$
  \item $a\in \Sigma: $ FIRST ($a$) = $\{a\}$
  \item a mixed string: $Y = Y_1 Y_2 \dots Y_n$
        \begin{enumerate}
          \item FIRST ($Y_1 \dots Y_n$) $\supseteq$ FIRST ($Y_1$) \ $\{\mathcal{\epsilon}\}$
          \item if $\mathcal{\epsilon} \exists$ FIRST ($Y_1$):
                \begin{enumerate}
                  \item $Y_1, Y_2, \dots, Y_n \to \mathcal{\epsilon}$
                  \item $Y_1, Y_2, \dots, Y_n \to Y_2, \dots, Y_n$
                \end{enumerate}
        \end{enumerate}
\end{enumerate}


\paragraph*{Example 3:}

$X \to X_1 | \dots | X_m$

FIRST ($X$) = FIRST ($X_1$) $\cup$ FIRST ($X_2$) $\cup \dots \cup$ FIRST ($X_m$)

% \begin{center}
%   \begin{tabular}{|c|c|}
%     FIRST (A) & FIRST (B) \\
%     \hline
%     4         & 5         \\
%     \hline
%     7         & 8         \\
%     \hline
%     9         & 10
%   \end{tabular}
% \end{center}

\paragraph*{Example 4: }
General Case

For $A \to \alpha _1 | \alpha _2 | \dots | \alpha _n$

if $\exists i, j$ such that $i \neq j$ and FIRST ($\alpha _i$) $\cap$ FIRST ($\alpha _j$) $\neq \emptyset$ then $A$ is not $LL(1)$.

\textbf{MUST BE DONE PAIRWISE, only needs to exist one pair to not be $LL(1)$.}

$\forall i, j: i \neq j \string^ (1 <= i, j <= n): FIRST (\alpha _i) \cap FIRST (\alpha _j) = \emptyset$ then $A$ is probably (necessary, but not sufficient) $LL(1)$.

\paragraph*{Example 5:}
General Case

For $A \to \alpha _1 | \alpha _2 | \dots | \alpha _n$

\vdots

$A_m \to \alpha _{m1} | \alpha _{m2} | \dots | \alpha _{mn_m}$

\end{document}